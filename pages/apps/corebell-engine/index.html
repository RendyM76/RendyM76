<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interface | Corebell Engine v0.0.01</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #1e1e1e;
      color: #ffffff;
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
    }

    #viewport {
      width: 100%;
      height: 100vh;
    }
  </style>
</head>
<body>
  <!-- Viewport for 3D Scene -->
  <div id="viewport"></div>

  <!-- Load Three.js, Cannon-es, OrbitControls, TransformControls, and dat.GUI from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/controls/TransformControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/postprocessing/BloomPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/shaders/CopyShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/postprocessing/ShaderPass.js"></script>

  <!-- Corebell Engine Script -->
  <script>
    // Scene, Camera, Renderer
    let scene, camera, renderer, controls, transformControls, world, composer;
    const objects = [];
    let selectedObject = null;

    // Initialize Corebell Engine
    function initCorebell() {
      // Set up Three.js scene
      scene = new THREE.Scene();

      // Set up camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 5, 15);

      // Set up renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x1e1e1e); // Dark background
      renderer.shadowMap.enabled = true; // Enable shadows
      renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Soft shadows
      document.getElementById('viewport').appendChild(renderer.domElement);

      // Add OrbitControls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true; // Smooth camera movement
      controls.dampingFactor = 0.05;

      // Add TransformControls
      transformControls = new THREE.TransformControls(camera, renderer.domElement);
      transformControls.addEventListener('dragging-changed', (event) => {
        controls.enabled = !event.value; // Disable OrbitControls while transforming
      });
      scene.add(transformControls);

      // Set up Cannon-es physics world
      world = new CANNON.World();
      world.gravity.set(0, -9.82, 0);

      // Add lighting
      const ambientLight = new THREE.AmbientLight(0x404040, 0.5); // Soft white light
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 1); // Bright white light
      directionalLight.position.set(5, 5, 5);
      directionalLight.castShadow = true; // Enable shadows
      directionalLight.shadow.mapSize.width = 2048; // High-res shadows
      directionalLight.shadow.mapSize.height = 2048;
      scene.add(directionalLight);

      // Add a ground plane with a grid helper
      const groundGeometry = new THREE.PlaneGeometry(20, 20);
      const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, side: THREE.DoubleSide });
      const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
      groundMesh.rotation.x = -Math.PI / 2; // Rotate to lie flat
      groundMesh.receiveShadow = true; // Ground receives shadows
      scene.add(groundMesh);

      const gridHelper = new THREE.GridHelper(20, 20);
      scene.add(gridHelper);

      // Add ground physics body
      const groundBody = new CANNON.Body({ mass: 0 });
      groundBody.addShape(new CANNON.Plane());
      groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
      world.addBody(groundBody);

      // Add a skybox
      const skyboxTexture = new THREE.CubeTextureLoader()
        .setPath('https://threejs.org/examples/textures/cube/pisa/')
        .load(['px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png']);
      scene.background = skyboxTexture;

      // Add post-processing (Bloom effect)
      const renderPass = new THREE.RenderPass(scene, camera);
      const bloomPass = new THREE.BloomPass(1.5, 25, 5, 512);
      const copyPass = new THREE.ShaderPass(THREE.CopyShader);
      composer = new THREE.EffectComposer(renderer);
      composer.addPass(renderPass);
      composer.addPass(bloomPass);
      composer.addPass(copyPass);

      // GUI Controls
      const gui = new dat.GUI();
      const params = {
        addCube: () => addCube(),
        addSphere: () => addSphere(),
        addCylinder: () => addCylinder(),
        deleteObject: () => deleteObject(),
        resetScene: () => resetScene(),
      };
      gui.add(params, 'addCube').name('Add Cube');
      gui.add(params, 'addSphere').name('Add Sphere');
      gui.add(params, 'addCylinder').name('Add Cylinder');
      gui.add(params, 'deleteObject').name('Delete Object');
      gui.add(params, 'resetScene').name('Reset Scene');

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);

        // Update physics
        world.step(1 / 60);

        // Sync physics and rendering
        objects.forEach(obj => {
          obj.mesh.position.copy(obj.body.position);
          obj.mesh.quaternion.copy(obj.body.quaternion);
        });

        // Update controls
        controls.update();

        // Render the scene with post-processing
        composer.render();
      }

      // Start animation loop
      animate();
    }

    // Add a cube to the scene
    function addCube() {
      const size = 1;
      const geometry = new THREE.BoxGeometry(size, size, size);
      const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.castShadow = true; // Cube casts shadows

      const body = new CANNON.Body({ mass: 1 });
      body.addShape(new CANNON.Box(new CANNON.Vec3(size / 2, size / 2, size / 2)));
      body.position.set(Math.random() * 5, 10, Math.random() * 5);

      scene.add(mesh);
      world.addBody(body);
      objects.push({ mesh, body });
    }

    // Add a sphere to the scene
    function addSphere() {
      const radius = 1;
      const geometry = new THREE.SphereGeometry(radius);
      const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.castShadow = true; // Sphere casts shadows

      const body = new CANNON.Body({ mass: 1 });
      body.addShape(new CANNON.Sphere(radius));
      body.position.set(Math.random() * 5, 10, Math.random() * 5);

      scene.add(mesh);
      world.addBody(body);
      objects.push({ mesh, body });
    }

    // Add a cylinder to the scene
    function addCylinder() {
      const radius = 1;
      const height = 2;
      const geometry = new THREE.CylinderGeometry(radius, radius, height, 32);
      const material = new THREE.MeshStandardMaterial({ color: 0x0000ff });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.castShadow = true; // Cylinder casts shadows

      const body = new CANNON.Body({ mass: 1 });
      body.addShape(new CANNON.Cylinder(radius, radius, height, 32));
      body.position.set(Math.random() * 5, 10, Math.random() * 5);

      scene.add(mesh);
      world.addBody(body);
      objects.push({ mesh, body });
    }

    // Delete the selected object
    function deleteObject() {
      if (selectedObject) {
        scene.remove(selectedObject.mesh);
        world.removeBody(selectedObject.body);
        objects.splice(objects.indexOf(selectedObject), 1);
        selectedObject = null;
        transformControls.detach(); // Detach transform controls
      }
    }

    // Reset the scene
    function resetScene() {
      objects.forEach(obj => {
        scene.remove(obj.mesh);
        world.removeBody(obj.body);
      });
      objects.length = 0;
      selectedObject = null;
      transformControls.detach(); // Detach transform controls
    }

    // Raycaster for object selection
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    // Handle mouse clicks
    window.addEventListener('click', (event) => {
      // Convert mouse position to normalized device coordinates
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      // Raycast from the camera
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(objects.map(obj => obj.mesh));

      if (intersects.length > 0) {
        // Select the first intersected object
        if (selectedObject) selectedObject.mesh.material.color.set(0x00ff00); // Reset previous selection
        selectedObject = objects.find(obj => obj.mesh === intersects[0].object);
        selectedObject.mesh.material.color.set(0xff0000); // Highlight selected object
        transformControls.attach(selectedObject.mesh); // Attach transform controls
      } else {
        // Deselect if no object is clicked
        if (selectedObject) selectedObject.mesh.material.color.set(0x00ff00);
        selectedObject = null;
        transformControls.detach(); // Detach transform controls
      }
    });

    // Initialize Corebell Engine on load
    window.addEventListener('load', initCorebell);

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
